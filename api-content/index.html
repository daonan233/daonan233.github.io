{"posts":[{"title":"“寻找泉州红色记忆” 社会实践项目成果展示","content":"福建泉州，古称鲤城，海上丝绸之路的起点城市，红色革命的兴盛之地。在2022年暑假，七位来自泉州的同学，组成了“寻找泉州红色记忆“小组，在这片家乡热土上寻找几十年前的红色记忆与英雄往事。 在长达一周的准备后，我们进行了为期四天的社会实践活动。 我们来到了泉州市文庙，探访了中共泉州特别支部，听讲解员讲述曾经的革命故事。 我们来到了泉州历史博物馆，在历史交错中看到了那段跌宕起伏的革命与发展往事。 我们来到了泉州晋江围头村“八二三“战地公园，遥听数十年前的炮火轰鸣。 我们拜访了著名的泉州开元寺，在赞叹古塔巍峨中寻觅曾经抗日民族英雄的壮烈事迹。 我们探寻“核将军”、全军挂相英模林俊德将军的故居，再重温一次“不能躺下，躺下就再也起不来了”的感动。 短短四天，我们寻访了古城泉州的红色往事，聆听了鲤城儿女的英雄风采。这次不寻常的红色之旅将使我们心中忠诚爱国的红色火苗越燃越旺。在这次意义非凡的社会实践活动之后，我们以家乡泉州的红色旅游发展为样板，为红色省份贵州探索出了一条以发展红色旅游产业为主的高质量发展路线。 ","link":"https://daonan233.github.io/post/pIqMbux_f/"},{"title":"SpringBoot 1.入门案例分析","content":"SpringBoot 2 开发 0.SpringBoot简介：由Pivotal团队提供的全新框架，其目的是用来简化Spring应用的初始搭建以及开发过程 优点： 起步依赖（简化依赖配置） 自动配置（简化常用工程相关配置） 辅助功能（内置服务器等） 1. 入门案例解析：parent 这个意思是什么呢，就是只要在pom.xml文件里面写了groupId和artifactId就可以了。SpringBoot已经把这些版本坐标给我们管理好了（depencyManagement定义了一系列的依赖管理）。 总结： 开发SpringBoot程序要继承spring-boot-starter-parent spring-boot-starter-parent中定义了若干个依赖管理 继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突 继承parent的形式也可以采用引入依赖的形式实现效果 2. 入门案例解析：starter SpringBoot中常见项目名称，定义了当前项目使用的所有依赖坐标，以达到减少依赖配置的目的 在实际开发中 使用任意坐标时，仅书写GAV中的G和A，V由SpringBoot提供，除非SpringBoot未提供对应版本V 如果发生坐标错误，再指定Version（小心版本冲突） 3.入门案例分析：引导类 4.入门案例分析：tomcat 里面放GA，就可以排除一个依赖(groupId&amp;artifactId) ","link":"https://daonan233.github.io/post/HM7jpvnA1/"},{"title":"生活记录3","content":"发一发我之前高中画的画，把他们扫描起来咯。🎨 （有一些不能放上来哈哈🤗） ps： 前一段时间阳了，没什么症状鸭，在家里隔离了一周。闷得慌！还不能洗澡555 ","link":"https://daonan233.github.io/post/_wfYsAJnO/"},{"title":"生活记录2","content":"这几天是北邮的离校返乡日📅 发现北邮每次返校和离校都刚好碰上疫情爆发，而且每次都比其他学校慢一截。这次的防控只能说做的不好不坏，很明显北邮是想放大家回去的，只要阴性就给解封，导员也在催学生回去。 我本来预定的是周三中午的飞机，所以打算早上八点半起床⏰。结果早上七点接到了昨晚已经去机场的女朋友的电话，然后七点半跟我一起去的哥们也来宿舍催我快走。这下才知道自己所在的楼出阳性了（2333我还是宿舍层长，直接跑路了） 当网约车载着我们离开北邮的时候，我才松一口气：不用在北邮包饺砸过大年了。🤣本来要跟我们同车的学姐所在楼层被封控了出不来，后来周三晚上解除隔离就去北京南站过夜了。 回家咯 回家后就是五天绿码居家隔离，相比之前舍友的红码+集中隔离感觉好多了。。福建的防疫政策果然很摆。😶 家里还新买了一个按摩椅，很贵！但是很爽！🤗 嘿嘿嘿。 ","link":"https://daonan233.github.io/post/ulq9N1zX3/"},{"title":"生活记录1","content":"买了个便携屏： 先说来源💡 💻配置：15.6 + 4K + 60hz 从福建群友那里400r买来的，是个裸屏（感觉好容易坏啊qwq，特别是下面的那块包起来的电路板），这个开关的大小不太好找到配套的diy外壳 我不太懂这方面的价格啊，但是看相似配置的都要贵不少，所以性价比还是很高了，4k的效果也很好。感谢这位朋友（小钻石💎） 估计这玩意就放学校了，有可能今年春节带回家里去自己动手搞个壳，然后再放来学校吧。 看看你的👀 正面：（和一些其他的设备🤤） 背面：（叙利亚战损版😭） 初冬的随拍📷 ","link":"https://daonan233.github.io/post/evJKClmXM/"},{"title":"数据结构笔记5：树","content":"后面填坑。。。 ","link":"https://daonan233.github.io/post/zUr2aaGie/"},{"title":"数据结构笔记4：串","content":"串 1.定义： 即字符串(String)，是由零个或多个字符组成的有限序列，一般记为S=‘a1a2a3…an' (n&gt;=0) 1.（位序从1开始而不是0！） 2.空串：长度为0（即不含任何字符）的串 3.空格串：由空格组成的非空串 2.串的基本操作： 常考的： Concat（&amp;T,S1,S2) SubString(&amp;Sub,S,pos,len)，pos为1开始 StrCompare(S,T) Index(S,T) 总结： ## 串的存储结构 **1.顺序存储结构定义：** 1.静态数组（不可变的） 2.动态数组（堆分配存储） 注意：ch[0]存储数组长度 教材使用的是，首位置废弃不用，但是同样记yigelength（若放在ch[0]只能存储到255 2.链式存储结构定义： 3.串的一些基本操作的实现：（基于顺序定长存储） 1.返回某位置后面的定长子串SubString(&amp;Sub,S,pos,len) ，用Sub返回 2.比较操作(S,T) 3.定位操作Index(S,T) 总结： ## 串的模式匹配 **1.定义：** 再主串找到与模式串相同的子串，并返回他的位置 朴素的模式匹配算法：狠狠的暴力！ 若模式串的长度为m，主串长度为n，则 1. 匹配成功的最好时间复杂度为O（m） 匹配失败的最好时间复杂度：O（n-m+1) =O(n-m)≈O（n） ## KMP算法 **1.算法进入** ![](https://daonan233.github.io/post-images/1668395425197.png) 从主串第一个开始，如果l后面不是e，那么也不用回溯了，因为我们知道主串第二个也不会符合模式串第一个。后面几个也同理 所以 我们就直接从l后面开始！ ——>如果j=k的时候才发现匹配失败，说明1~k-1都匹配成功 意思就是 ：如果到最后一个才发现错了 对于主串，就算不匹配了，指针也不回溯！ 对于子串，指针则要返回到串首，狠狠的回溯！ 算法实现： 重点来力！如何构造next数组! 两个例子： 练习： 这里，特别的，next[1]=0,next[2]=1; 然后就是对比前缀的子串和后缀的子串最多能相同的个数 比如上面的第六个，它前面的为ababa， 那么前缀就是abab及其子串，后缀就是baba及其子串 那么当前缀的字串为aba，后缀字串为aba的时候， 一样的最多为3个 所以，3+1=4 最终，我们的求next数组和KMP算法是这样的！ 总结： 还有一种 优化的KMP算法（把next数组优化成nextval数组，减少了几次无用的判断） ","link":"https://daonan233.github.io/post/gAGzadL2p/"},{"title":"数据结构笔记3：栈和队","content":"栈 1.定义： 栈（Stack)是只允许仔一段进行插入或删除操作的线性表 逻辑结构与普通线性表相同 栈是后进先出的（LIFO） 2.几个术语 栈顶：允许插入和删除的一端 栈底：不允许插入和删除的一端 3.栈的基本操作： 注意：GetTop只返回栈顶元素的值，Pop则是返回栈顶元素的值并删除他（出栈） 4.常考考题： 已知进栈顺序，判断选项里哪种是合法的栈顺序 （略） ## 顺序栈的实现 **1.定义：** ![](https://daonan233.github.io/post-images/1668135702781.png) 用顺序存储方式实现的栈 声明一个SqStack s, 就会在内存里面分配空间 2.初始化操作： 为什么要把栈顶指针设置为-1？ 因为要让栈顶指针指向当前栈顶的位置，而栈空的时候没有元素，不能指在0的位置 3.入栈操作 注意不能写成top++！ 当新元素的入栈之前，要让栈顶指针指向要入的位置 4.出栈操作： 注意，这里写的就是top--。因为你要先删除才能指向当前新的栈顶。 （其实数据还残留在内存中，只是逻辑上被删除了） 5.读取栈顶元素： 和pop的唯一区别就是 top指针不变 P.S.当然 也有另外一种写法，就是栈顶指针指向栈顶元素的前一个。 那么就是 top++， --top，要注意审题哦 栈满的时候，top==maxsize 当然呢 也可以使用共享栈来提高空间利用率（略） 链栈 1.定义 队列 1.定义： 是只允许在一端进行插入，在另一端删除的线性表 队列的特点：先进先出(FIFO) 2.重要术语： 队头：允许删除的一端 队尾：允许插入的一端 空队列 3.队列中的基本操作： ## 队列的顺序实现 ** 1.队列的定义：** 这里的队尾指针指向队尾元素的后一个位置(下一个应该插入的位置） 2.队列的初始化 3.入队操作在（只能从队尾入队）： 啥时候队列已满？： Q.front = maxsize-1 3.5循环队列： 效果图: 为什么空出来的地方不能再存储？因为这时候 rear指针就会指向front位置，那么就会满足“队列为空“的条件。 而开始的时候（即队列为空的时候），rear指针就是指向front的位置的。 所以循环队列最多能存储的数据个数为maxsize-1个 当然，也可以加一个int size来判断元素个数 或者加一个int tag (删除为0，插入为1），队满的条件为frontrear&amp;&amp;tag1 总结 ## 队列的链式实现 1.定义方法 2.初始化： 1.带头结点的 2.不带头结点的 3.入队： 1.（带头结点的） 2.（不带头结点的） 每次操作之后都要让rear指针指向新的表尾结点，第一次入队要改变队头指针指向头结点，后面就不用了 4.出队操作： 1.带头结点的 如果删除的是最后一个结点出队，那就还要让rear指针指向front（还原为空队列） 2.不带头结点的： 5.队列满的条件 （一般不会队满）：不关心 6.最后还是注意一个点： ## 双端队列 ___ ## 栈的应用：括号匹配 **碰到左括号就入栈，遇到右括号，就消耗一个左括号 ** 1.若遇到右括号的时候pop出的左括号不匹配时，就匹配失败了！ 2.若处理完所有括号后，栈不为空，也匹配失败！ 算法实现: 考试中可以直接使用基本操作，但是要简要说明接口是啥（写个注释。 （其实用链栈比较严谨，不会溢出。不过考试用顺序栈更简单） 递归的函数调用栈 特殊矩阵的压缩存储 对称矩阵的压缩存储： 1.行优先原则： 注意，这里的矩阵是从1开始的，而数组从0开始 列优先原则： 三角矩阵的压缩存储： 1.下三角矩阵 2.上三角矩阵 ","link":"https://daonan233.github.io/post/BvI6qhtVq/"},{"title":"数据结构笔记2：线性表","content":"线性表（Linear List） **1.线性表的定义** ![](https://daonan233.github.io/post-images/1668133018554.png) 几个性质： 1.逻辑结构，每个元素都是一样的数据类型 2.每个数据元素占空间一样大 3.有次序 线性表的初始操作 总结：创销、增删改查 1.InitList(&amp;L)：初始化表。构造一个空的线性表L，分配内存空间 2.DestroyList(&amp;L) ：销毁操作。销毁线性表，并释放线性表L所占用的内存空间 3.ListInsert(&amp;L,i,e)：插入操作。在表L的第i个位置上插入指定元素e 4.ListDelete（&amp;L,I,&amp;e)：删除操作。删除表L中第i个位置的元素，并用e 返回删除元素的值。 5.LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。 6.GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值 ps：什么时候要传入参数的引用“&amp;&quot;----对参数的修改结果需要”带回来“ （调用带有&amp;传引用的函数时，原来的值就会被改变，即”被带回来“ 顺序表的定义 定义：用顺序存储的方式实现线性表 顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的临接关系来体现 1.顺序表的实现——静态分配 所以我们就需要： 2.顺序表的实现——动态分配 Key:动态申请和释放内存空间： C——malloc 、 free函数 顺序表的基本操作：插入（以静态分配为例子） 两个步骤：1. i 位置以及其后面的每个都往后移动一位(循环） 2.将第 i 个位置的值赋为e ps:要给出一些边界判断以及合法性的错误反馈 时间复杂度：（省流：平均n/2，时间复杂度O（n）） 顺序表的基本操作：删除 （第i个元素在顺序表里面是L.data[i-1]) 1.为什么这里的e要加引用符号？ 因为这样才能把参数e 带回来，加了引用符号后，函数里的e和main函数里的e在内存中 占同一个位置，后面输出e的时候才能把e输出出来，否则就还是原来初值的e。 时间复杂度：O(n) 顺序表的基本操作：查找 1.GetElem(L,i)， 按位查找操作 1.1若为静态分配的顺序表，其实就直接返回L.data[i-1] 1.2若为动态分配的顺序表，一样 这俩的时间复杂度都为O(1) 2.LocateElem(L,e)，按值查找操作 3.顺序表的优缺点： （随机存取，顺序存储，在物理上连续存放） 单链表 1.用代码定义一个单链表： 然鹅我们书里面是这样定义的，更加简洁： 强调是一个单链表：使用LinkList 强调是一个结点：使用LNode* ！！！LinkList等价于Lnode * ！！！ 2.初始化一个不带头结点的单链表 这里，要判断单链表是否为空，就用L==NULL是否为真 3.初始化带头结点的单链表： 用头结点指向的next域判断是否要成为头结点 L-&gt;next == NULL 大家都用带头结点的！头结点的下一个结点才开始存储数据 4.尾插法单链表按位序插入删除（带头结点的） ListInsert(&amp;L,I,e) :插入操作。在L的第i个位置上插入指定元素e。 其实也就是找到第i-1个结点，将新结点插入其后 《注意倒二倒三行不能颠倒哦》 这个是尾插法 顺序：0.让p指针依次往后扫描 注意循环找到第i-1个结点 1.新创造一个结点s，给s申请内存 2.把e的值赋给s的数据域 3.p的next域赋值给s的next域 4.把结点s连到p的next上（其实3、4相当于在p后面生成了一个s。但是p是渣男，刚来就要走了） 5.返回true，表示创建成功 4.5 尾插法单链表按位序插入删除（不带头结点） 更麻烦，第一个结点的情况需要单独拿出来考虑，这个略 大家要注意考试两个都会考，但是一般默认带头结点的 上面这俩都是尾插法，时间复杂度都是O(n) 5.指定结点的前插操作： 6.按位序删除（带头结点）： 原理和插入差不多 主要是最后三点： 0.p在挨个搜索 1.让新定义的q指向被删除的结点的前一个结点的next域 2.用e返回q的data域 3.q的next域赋给p的next域（和插入相反） 7.指定结点的删除：（带头结点） 8.按位查找 9.建立一个单链表（头插，尾插） 9.1 尾插法建立单链表 这里while里面的操作是这样的： （s的意思是新申请的结点，r的意思是始终指向表尾的尾结点指针（这个重要）） 1.给新结点s申请一个空间 2.把x的值赋给该新申请节点s的数据域 3.s的位置给r的next域 4.s成为新的表尾，r指向s结点 注意，最开始的L的next域可以不指向NULL(不会指向脏数据），但是肯定可以加上，也建议加上 9.2头插法建立单链表 去掉这一句就可能指向内存里的脏数据 注意：头插法可以用于链表的逆置！ 顺序： 1.给新结点s申请空间 2.x的值赋给s的data域 3.L的next域赋给s的next域 4.s成为L的next域 单链表的优缺点： 循环链表 一丢丢小小的差别：循环单链表的表尾结点的next指针指向头结点 另外一个不一样的点！ 单链表从一个结点出发只能找到后续的各个节点 循环单链表从一个结点出发可以找到其他任何一个结点 （从头结点找到尾部，时间复杂度为O（n） （从尾部找到头部，时间复杂度为O（1） 1.循环双链表的初始化； 2.双链表的插入 3.删除 总结： 双链表 静态链表 顺序表和链表的比较 Round 1：逻辑结构 都属于线性表，都是数据结构 Round 2 ：优缺点比较 顺序表：顺序存储 优点：支持随机存取，存储密度高 缺点：大片连续空间分配不容易，改变容量不方便 链表：链式存储 优点：离散的小空间分配方便，改变容量方便 缺点：不可随机存取，存储密度低 Round 3 ：基本操作 创销、增删改查 创： 顺序表：1.需要预分配大片连续空间 2.若为静态分配，则容量不可改变 3.若为动态分配，容量可改变，但需要移动大量元素，时间代价高 链表：只需要分配一个头结点（也可以不要头结点，只声明一个头指针）方便后面拓展 显然链表灵活性优于顺序表 销： 顺序表：1.修改length=0（一个标志而已） 2.1静态分配：系统自动回收空间 2.2动态分配：需要手动free ，free(L.data)（malloc在堆区申请的空间） 链表：依次删除各个结点（free） 增删： 顺序表：插入/删除元素要将后续元素都后移、前移。 时间复杂度O(n)，时间开销主要来自于移动元素。 （若数据元素很大，则移动的时间代价很高） 链表：插入删除元素只需要修改指针即可 时间复杂度O(n)，时间开销主要来自于查找目标元素 （查找元素的时间代价更低） 所以链表的增删效率更高！ 查： 顺序表：按位查找：O(1) 按值查找：O(n)，若表内元素有序，可在O（log2n）时间内找到 链表：按位查找：O(n) 按值查找：O(n) 顺序表的效率更高！ 总结： ","link":"https://daonan233.github.io/post/dz6SR8bYk/"},{"title":"数据结构笔记1: 时间、空间复杂度","content":"** 算法时间复杂度T**：事先预估算法时间开销T(n)与问题规模n的关系 知识点： 1.当问题规模n足够大的时候，只需要考虑阶数高的部分（忽略长度） 2.大O表示法 ：大O表示”同阶“，同等数量级。即n趋于无穷时，二者之比为常数。 3. 常对幂指阶 结论： 1.顺序循环的代码只会影响常数阶，可以忽略 2.如果有多层嵌套循环，只需关注最深层循环了几次。 ","link":"https://daonan233.github.io/post/rUrdPESWn/"},{"title":"About Me","content":"👏 欢迎来到道难（daonan）的个人博客 ！ ✍️ 我会在这里记录一些关于我的想法，笔记等等，敬请期待！ 关于我👇 📝 主要学习经历 北京邮电大学 计算机学院（国家示范性软件学院） 软件工程 本科（2022~ ） 北京邮电大学 信息与通信工程学院 信息与通信工程大类 本科（2021~2022） 福建省永春第一中学 高中（2018~2021） 福建省永春第一中学 初中（2015~2018） 🌉 兴趣爱好 游戏： 音乐游戏，举例：phigros，BangDream！，Muse Dash等。 RPG游戏：举例：Fate/Grand Order，小众rpg游戏，使用过rpgmaker。 FPS游戏，举例：OverWatch，CountStrike等。 音乐： 日vocaloid，以初音未来（Hatsune Miku）为主 YOASOBI 宇多田ヒカル Radwinps 米津 玄師 Roselia LiSA 绘画： 很菜，主要纸绘，尝试过板绘。 ​ 旅游： 哪里都行，喜欢海边，不喜欢爬山 不喜欢写代码。 💻 代码相关的技能点（有相关项目请dd我） 前端： ​ 1.较熟练使用html5+css3+js，常用框架为BootStrap ​ 2.JavaFX学习中 后端： ​ JavaSSM(Spring+SpringMVC+Mybatis)学习中 语言： ​ Java、C/C++、html+css+js、python（目前使用频度，降序） 🌎 你可以在以下网页里找到我 知乎 bilibili Github Gitee CSDN 💬 联系方式 可以通过以下邮箱联系我： 163邮箱：daonan55@163.com 谷歌邮箱：daonan233@gmail.com 😘欢迎你来到我的博客小站，刚刚起步，请多指教 ","link":"https://daonan233.github.io/post/hello-gridea/"},{"title":"使用git向github克隆本地文件夹的方法","content":" 0 : 首先需要拥有一个github账号 ​​​​​​GitHub: Where the world builds software，并且下载好git 1 : 在右上角头像旁边的加号里面点击“new repository”，创建一个库。 第一个选项 2 : 在这里配置你的库（是否开源，名称、解释、readme等） 这里我勾上了创建一个readme的选项（默认没勾），如果不在这里勾的话后面也可以再加上去。 配置你的库的初始设置 2.5 ：如果你没有勾选readme，那么会出现下面这个页面 这里选择红线的位置（比如选择upload files），可以先自己随便丢一个文件上去占位（github不允许有空的文件夹）。 3 : 点击绿色的code按钮，复制你的github url（如图中红框所示） 先复制到剪切板，实在不行新建个文本文档扔进去 4 ： 在本地磁盘里新建一个空文件夹，并打开该文件夹，右键“git bash here” 5 ： 输入 git clone github url 这里指的是你刚才在github上复制的github url （右键paste），回车 出现这样就是成功 这里就会出现你在github上面的库的克隆文件夹 6 ： 输入cd 库名 ，回车进入这个克隆来的库的文件夹 比如我我当时在github命名这个库叫examples，我就输入 cd examples 如图，这里就进入了examples这个子目录 7 ： 把需要的文件夹放入这个克隆库文件夹里面 8 ： 输入 git init 初始化文件夹 9 ： 输入 git add . (注意add后先有个空格，然后有个点） ，上传你的文件夹。 10 ： 输入 git commit -m &quot;描述信息” 这里会显示你都上传了哪些文件 10.5 ：这里可能还会要求你输入用户名和密码，可以使用下面任一命令来进行身份认证 git config --global user.email &quot;你的注册邮箱&quot; git config --global user.name &quot;你的用户名&quot; 11 ：输入 git push 这里就是把你的文件push到github上你的库里。回到github页面，刷新一下，看看是否成功 11.5 ： 如果上面没有成功，尝试输入 git push -u origin master 这里你推送的branch应该为master，如果为其他branch则改master部分。 11.55 ： 如果因为readme文件不在本地目录中而失败，尝试 git pull --rebase origin master （注意是pull） 12 ：中间出现的问题基本由于网不稳定导致。 ","link":"https://daonan233.github.io/post/shi-yong-git-xiang-github-ke-long-ben-di-wen-jian-jia-de-fang-fa/"}]}